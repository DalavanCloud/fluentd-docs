# Writing Plugin Test Code

This article explains how to write Fluentd plugin test code using [test-unit](https://test-unit.github.io/).

NOTE: You can write test code with any other testing framework such as RSpec, minitest and etc.

## Basics of Plugin Testing

Fluentd provides useful Test Drivers according to plugin type. We can write maintainable test code for plugins using them.

## Plugin Test Driver Overview

There are useful Test Drivers for plugin testing. We can write test code for plugins as following:

    :::ruby
    # Load the module that defines common initialization method (Required)
    require 'fluent/test'
    # Load the module that defines helper methods for testing (Required)
    require 'fluent/test/helpers'
    # Load the test driver (Required)
    require 'fluent/test/driver/output'
    # Load the plugin (Required)
    require 'fluent/plugin/out_file'

    class FileOutputTest < Test::Unit::TestCase
      include Fluent::Test::Helpers

      def setup
        Fluent::Test.setup   # setup test for Fluentd (Required)
        # setup test for plugin (Optional)
        # ...
      end

      def teardown
        # terminate test for plugin (Optional)
      end

      def create_driver(conf = CONFIG)
        Fluent::Test::Driver::Output.new(Fluent::Plugin::FileOutput).configure(conf)
      end

      # configuration related test group
      sub_test_case 'configuration' do
        test 'basic configuration' do
          d = create_driver(basic_configuration)
          assert_equal 'somethig', d.instance.parameter_name
        end
      end

      # Another test group goes here
      sub_test_case 'path' do
        test 'normal' do
          d = create_driver('...')
          d.run(default_tag: 'test') do
            d.feed(event_time, record)
          end
          events = d.events
          assert_equal(1, events.size)
        end
      end
    end


## Testing Utility Methods

You can get your plugin instance when you call Test Driver instance's ``#instance`` method.
If utility methods are private, you can use ``__send__``.

    :::ruby
    # ...
    class FileOutputTest < Test::Unit::TestCase
      # ...
      # Group by utility method
      sub_test_case '#compression_suffix' do
        test 'returns empty string for nil (no compression method specified)' do
          d = create_driver
          assert_equal('', d.instance.compression_suffix(nil))
        end
      end
    end

## Test Driver Base API

#### initiazlie(klass, opts: {}, &block)

TODO

#### configure(conf, syntax: :v1)

TODO

#### end_if(&block)

TODO

#### break_if(&block)

TODO

#### broken?

TODO

#### run(timeout: nil, start: true, shutdown: true, &block)

TODO

#### stop?

#### logs

TODO

#### instance

TODO

## Test Driver Base Owner API

#### events(tag: nil)

TODO

#### event_streams(tag: nil)

TODO

#### emit_count

TODO

#### record_count

TODO

#### error_events(tag: nil)

TODO

## Test Driver Event Feeder API

#### feed(tag, time, record)

Feed an event to plugin instance.

- `tag`: the tag of the event
- `time`: event timestamp
- `record`: event record

Code example:

    :::ruby
    d.run do
      d.feed("test", event_time, { "message" => "Hello, Fluentd!!" })
    end


#### feed(tag, array_event_stream)

Feed an array of event stream to plugin instance.

- `tag`: the tag of the event
- `array_event_stream`: array of `[time, record]`
  - `time`: event timestamp
  - `record`: event record

Code example:

    :::ruby
    d.run do
      d.feed("test", [
        [event_time, { "message" => "Hello, user1!!" }],
        [event_time, { "message" => "Hello, user2!!" }]
      ])
    end

#### feed(tag, es)

Feed an event stream to plugin instance.

- `tag`: the tag of the event
- `es`: event stream object

Code example:

    :::ruby
    es = Fluent::OneEventStream.new(event_time, { "message" => "Hello, Fluentd!!" })
    d.run do
      d.feed("test", es)
    end

#### feed(record)

Feed an event with default tag to plugin instance.

- `record`: event record

Code example:

    :::ruby
    d.run(default_tag: "test") do
      d.feed({ "message" => "Hello, Fluentd!!" })
      # Above is same as below
      d.feed(event_time, { "message" => "Hello, Fluentd!!" })
    end

#### feed(time, record)

Feed an event with default tag to plugin instance.

- `time`: event timestamp
- `record`: event record

Code example:

    :::ruby
    d.run(default_tag: "test") do
      d.feed(event_time, { "message" => "Hello, Fluentd!!" })
    end

#### feed(array_event_stream)

Feed an array of event stream with default tag to plugin instance.

- `array_event_stream`: array of `[time, record]`
  - `time`: event timestamp
  - `record`: event record

Code example:

    :::ruby
    d.run(default_tag: "test") do
      d.feed([
        [event_time, { "message" => "Hello, user1!!" }],
        [event_time, { "message" => "Hello, user2!!" }]
      ])
    end

#### feed(es)

Feed an event stream with default tag to plugin instance.

- `es`: event stream object

Code example:

    :::ruby
    es = Fluent::OneEventStream.new(event_time, { "message" => "Hello, Fluentd!!" })
    d.run(default_tag: "test") do
      d.feed(es)
    end

## Test Driver Filter API

#### filtered_records

TODO

## Test Driver Output API

#### formatted

TODO

#### flush

TODO

## Test helpers

#### assert_equal_event_time(expected, actual, message = nil)

Assert EventTime instance.

- `expected`: expected EventTime instance
- `actual`: actual EventTime instance
- `message`: message that is displayed when assertion failure

Code example:

    :::ruby
    parser = create_parser
    parser.parse(text) do |time, record|
      assert_equal_event_time(event_time("2017-12-27 09:43:50.123456789"), time)
    end

#### config_element(name = 'test', argument = '', params = {}, elements = [])

Create `Fluent::Config::Element` instance.

- `name`: element name such as "match", "filter", "source", "buffer", "inject", "format", "parse" and etc.
- `argument`: argument for section defined by `config_argument`
- `params`: parameters for section defined by `config_element`
- `elements`: child elements of this element

Code example:

    :::ruby
    conf = config_element('match', '**', {
      'path' => "#{TMP_DIR}/prohibited/${tag}/file.%Y%m%d.log",
    }, [
         config_element('buffer', 'time,tag', {
          'time_key' => 86400,
          'timekey_zone' => '+0000'
        })
      ]
    )
    d = create_driver(conf)

#### event_time(str = nil, format: nil)

Create `Fluent::EventTime` instance.

- `str`: time represented as string
- `format`: parse `str` as time according to this format. See also [Time.strptime](https://docs.ruby-lang.org/en/trunk/Time.html#method-c-strptime)

Code example:

    :::ruby
    time = event_time
    time = event_time("2016-10-03 23:58:09 UTC)
    time = event_time('2016-04-11 16:40:01 +0000')
    time = event_time("2016-04-17 11:15:00 -0700")
    time = event_time("2011-01-02 13:14:15")
    time = event_time('Sep 11 00:00:00', format: '%b %d %H:%M:%S')
    time = event_time('28/Feb/2013:12:00:00 +0900', format: '%d/%b/%Y:%H:%M:%S %z')
    time = event_time("2017-02-06T13:14:15.003Z", format: '%Y-%m-%dT%H:%M:%S.%L%z')

#### with_timezone(tz)

Process given block with `tz`. This method overwrites `ENV['TZ']` while processing block.

- `tz`: Timezone. This is set to `ENV['TZ']`.

Code example:

    :::ruby
    time = with_timezone("UTC+02") do
      parser = Fluent::TimeParser.new("%Y-%m-%d %H:%M:%S.%N", true)
      parser.parse("2016-09-02 18:42:31.123456789")
    end
    assert_equal_event_time(time, event_time("2016-09-02 18:42:31.123456789 -02:00", format: '%Y-%m-%d %H:%M:%S.%N %z'))

#### with_worker_config(root_dir: nil, workers: nil, worker_id: nil, &block)

Process block with given parameters. This method overwrites system config while processing block.

This is useful for testing Fluentd internal behavior related to multi workers.

- `root_dir`: TODO
- `workers`: TODO
- `worker_id`: TODO

Code example:

    :::ruby
    class Dummy < Fluent::Plugin::Output
    end
    d = Dummy.new
    with_worker_config(workers: 2, worker_id: 1) do
      d.configure(conf)
    end
    ...

#### time2str(time, localtime: false, format: nil)

Convert `time` to string.

This is useful for testing formatter.

- `time`: `Fluent::EventTime` instance. See also [Time.at](https://docs.ruby-lang.org/en/trunk/Time.html#method-c-at)
- `localtime`: If `true`, process `time` as localtime. Otherwise UTC.
- `format`: See also [Time#strftime](https://docs.ruby-lang.org/en/trunk/Time.html#method-i-strftime).

    :::ruby
    formatter = configure_formatter(conf)
    formatted = formatter.format(tag, time, record)
    assert_equal("#{time2str(time)}\t#{JSON.dump(record)}\n", formatted)

#### msgpack(type)

Shorthand for `Fluent::MessagePackFactory.factory`, `Fluent::MessagePackFactory.packer` and `Fluent::MessagePackFactory.unpacker`.

- `type`: Available types are `:factory`, `:packer`, `:unpacker`.

Code example:

    :::ruby
    events = []
    factory = msgpack(:factory)
    factory.unpacker.feed_each(binary) do |obj|
      events << obj
    end

#### capture_stdout

Capture stdout while processing given block.

This is useful for testing Fluentd utility commands.

Code example:

    :::ruby
    captured_string = capture_stdout do
      # Print something to STDOUT
      puts "Hello!"
    end
    assert_equal("Hello!\n", capture_stdout)


## Testing Input Plugins


## Testing Filter Plugins


## Testing Output Plugins


## Testing Parser Plugins

You must test parser plugins' ``#parse`` method.

You can write parser plugins test like below.

Code example:

    :::ruby
    require 'fluent/test'
    require 'fluent/test/driver/parser'
    require 'fluent/test/helpers'
    require 'fluent/plugin/parser_my'

    class MyParserTest < Test::Unit::TestCase
      include Fluent::Test::Helpers
      
      setup do
        Fluent::Test.setup
      end
      
      def create_driver(conf={})
        Fluent::Test::Driver::Parser.new(Fluent::Plugin::MyParser).configure(conf)
      end
      
      def create_parser(conf)
        create_driver(conf).instance
      end

      test "parse" do
        parser = create_parser(conf)
        parser.parse(text) do |time, record|
          assert_equal(event_time("2017-12-26 11:56:50.1234567879"), time)
          assert_equal({ "message" => "Hello, Fluentd!!" }, record)
        end
      end
    end

## Testing Formatter Plugins

You must test formatter plugins' ``#parse`` method.

You can write formatter plugins test like below.

Code example:

    :::ruby
    require 'fluent/test'
    require 'fluent/test/driver/formatter'
    require 'fluent/test/helpers'
    require 'fluent/plugin/formatter_my'

    class MyFormatterTest < Test::Unit::TestCase
      include Fluent::Test::Helpers
      
      setup do
        Fluent::Test.setup
      end
      
      def create_driver(conf={})
        Fluent::Test::Driver::Formatter.new(Fluent::Plugin::MyFormatter).configure(conf)
      end
      
      def create_formatter(conf)
        create_driver(conf).instance
      end

      test "format" do
        formatter = create_formatter(conf)
        formatted = formatter.format(tag, time, record)
        assert_equal("message:awesome\tgreeting:hello", formatted)
      end
    end

## Tests for logs

Testing log is very easy.

Code example:

    :::ruby
    # d is a Test Driver instance
    assert_equal(1, d.logs.size)
    logs = d.logs
    assert do
      logs.any? {|log| log.include?(expected_log) }
    end
    assert do
      logs.last.match?(/This is last log/)
    end

